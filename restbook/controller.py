
'''A controller that stores restaurants and bookings in memory.'''

###############################################################################

from collections import defaultdict
from uuid import uuid1 as generate_id

##############################

from restbook import entities
from restbook import usecases as use

###############################################################################

'''
Restaurants and bookings are stored in dictionaries with their
unique id acting as the key.
'''

_restaurants = {}
_bookings = {}

'''
We associate bookings with restaurants by listing them in a
dictionary using the restaurant ID as the key.
'''

_bookings_by_restaurant = defaultdict(list)

###############################################################################

def restaurant_create(name, description, opening_times=None, tables=None):
    '''
    Takes the properties of a restaurant, generates a UUID for it and,
    if that restaurant passes validation, stores it for later retreival.
    If a restaurant is successfully stored, its UUID is returned.
    Otherwise, the return value is None.
    '''

    id = generate_id()

    restaurant = entities.Restaurant(
        name=name,
        description=description,
        opening_times=opening_times,
        tables=tables
    )

    if restaurant.is_valid():
        _restaurants[id] = restaurant
        return id
    else:
        return None

##############################

def restaurant_from_id(id):
    '''
    Attempts to retreive a Restaurant according to the UUID returned by
    restaurant_create. Returns that Restaurant if found, otherwise
    returns None.
    '''

    try:
        return _restaurants[id]
    except KeyError:
        return None

###############################################################################

def booking_create(restaurant_id, reference, covers, start, finish):
    '''
    Takes a restaurant_id generated by restaurant_create, a booking
    reference, number of covers and a start and finish time and makes
    a booking using those details. The UUID of the new booking is
    returned if successful. Otherwise None is returned.
    '''

    restaurant = restaurant_from_id(restaurant_id)

    if not restaurant:
        return None

    restaurant_open = use.fulfills_times(
        opening_times=restaurant.opening_times,
        start=start,
        finish=finish
    )

    if not restaurant_open:
        return None

    opening_time, closing_time = restaurant_open[0]

    tables = restaurant.tables

    existing_bookings = use.relevant_bookings(
        bookings=_bookings_by_restaurant[restaurant_id],
        datetime_context=start,
        start_offset=opening_time,
        end_offset=closing_time
    )

    requested_booking = entities.Booking(
        reference=reference,
        covers=covers,
        start=start,
        finish=finish
    )

    if use.space_available(requested_booking, tables, existing_bookings):
        id = generate_id()
        _bookings[id] = requested_booking
        _bookings_by_restaurant[restaurant_id].append(requested_booking)
        return id
    else:
        return None

##############################

def booking_from_id(id):
    '''
    Attempts to retreive a Booking according to the UUID returned by
    booking_create. Returns that Booking if found, otherwise returns
    None.
    '''

    try:
        return _bookings[id]
    except KeyError:
        return None

##############################

def generate_report(restaurant_id, date):

    restaurant = restaurant_from_id(restaurant_id)

    report = ['Restaurant: {}'.format(restaurant.name)]

    start_of_day = date.replace(hour=0, minute=0)
    end_of_day = date.replace(hour=23, minute=59)

    matching_times = use.opens_within_times(
        opening_times=restaurant.opening_times,
        start=start_of_day,
        finish=end_of_day
    )

    for time_opens, time_closes in matching_times:
        report.append('\tOpening Period: {}-{}'.format(time_opens, time_closes))

        booked = use.relevant_bookings(
            bookings=_bookings_by_restaurant[restaurant_id],
            datetime_context=date,
            start_offset=time_opens,
            end_offset=time_closes
        )

        for table, bookings in use.seating_plan(restaurant.tables, booked).items():
            report.append(
                '\t\t{table_number}: {bookings}'.format(
                    table_number=table,
                    bookings=[str(x) for x in bookings]
                )
            )

    return '\n'.join(report)

